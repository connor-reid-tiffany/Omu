---
title: "Omu, a Metabolomics Analysis R Package"
author: "Connor R. Tiffany"
date: "3/21/2018"
output:
  html_document:
    toc: yes
    toc_float: yes
  pdf_document:
    latex_engine: xelatex
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction to Omu

Omu is an R package that enables rapid analysis of Metabolomics data sets, and the creation of intuitive graphs. Omu can assign metabolite classes (Carbohydrates, Lipids, etc) as meta data, perform t tests, anovas and principle component analysis, and gather functional orthology and gene names from the KEGG database that are associated with the metabolites in a dataset. This package was developed with inexperienced R users in mind.


## Data Analysis


### Data Format

Included with Omu is an example metabolomics dataset of data from fecal samples collected from a two factor experiment with wild type c57B6J mice and c57B6J mice with a floxed nos2 gene KO, that were either mock or treated with streptomycin(an antibiotic), and a metadata file giving group values for each of the samples in the metabolomics data. To use Omu, you need a metabolomics count data frame in .csv format that resembles the example dataset, with the column headers Metabolite, KEGG, and then one for each of your samples. Row values are metabolite names in the Metabolite column, KEGG cpd numbers in the KEGG column, and numeric counts in the Sample columns. Here is a truncated version of the sample data in Omu as a visual example of this:

```{r echo=FALSE, warning=FALSE, message=FALSE}
library(Omu)
library(knitr)
load("Omu/Omu/data/c57_nos2KO_mouse_countDF.rda")
load("Omu/Omu/data/c57_nos2KO_mouse_metadata.rda")
df_trunc <- c57_nos2KO_mouse_countDF[,1:3]
kable(df_trunc[1:4,])
```

The meta data file should have a Sample column, with row values being sample names, and then a column for each Factor in your dataset, with row values being groups within that factor. Here is a truncated version of the metadata that accompanies the above dataset:

```{r echo=FALSE, message=FALSE, warning=FALSE}
kable(c57_nos2KO_mouse_metadata[1:4,])
```

### Assiging Hierarchical Class Data

Omu can assign hierarchical class data for metabolites, functional orthologies, and organism identifiers associated with gene names. It does this using data frames located in the system data of the package(these can not be viewed or edited by the user, but the tables are available on the Omu github page in .csv format). To assign hierarchical class data, use the ```assign_hierarchy``` function and pick the correct identifier, either "KEGG", "KO_Number", "Prokaryote", or "Eukaryote". For example, using the germ_free_countDF.RData that comes with the package, lets assign compound class hierarchy data.


```
DF <- assign_hierarchy(data = c57_nos2KO_mouse_countDF, keep_unknowns = TRUE, identifier = "KEGG")
```

Here, we chose to keep unidentified compounds without KEGG numbers, and assigned the metabolite class hiearchy data by KEGG cpd number. The output DF should look like this:

```{r echo=FALSE,message=FALSE, warning=FALSE}
data = c57_nos2KO_mouse_countDF
data = assign_hierarchy(data = data, keep_unknowns = TRUE, identifier = "KEGG")
c57_nos2KO_mouse_countDF = c57_nos2KO_mouse_countDF[,1:2]
DF <- assign_hierarchy(data = c57_nos2KO_mouse_countDF, keep_unknowns = TRUE, identifier = "KEGG")
kable(DF[1:4,])
```


### Modeling with Univariate Statistics

Omu supports two univariate statistical models, t test and anova, using the functions ```T_Test``` and ```anova_function``` respectively. Most scaled metabolomics count matrices can have a normal distribution fit to them without issue, so both of these models are useful for observing relationships between your independent variables. Lets take the dataframe we created using the assign_hierarchy function and use ```T_Test``` to run statistics on it. We will also need to use the ```c57_nos2KO_mouse_metadata``` data frame included with the package. Lets compare the "WT" group in our dataset to the "Nos2" group to observe if genetic background had an effect on the metabolome, and log transform our data so the model has a better fit.

```
DF_stats <- T_Test(data = DF, colData = c57_nos2KO_mouse_metadata, numerator = "Nos2", denominator = "WT", response_variable = "Metabolite", Factor = "Background", log_transform = TRUE)
```
Once the function has finished running, you should have a dataframe object with new columns added:
```{r echo=FALSE,message=FALSE, warning=FALSE}
library(plotrix)
DF_stats <- T_Test(data = data, colData = c57_nos2KO_mouse_metadata, numerator = "Nos2", denominator = "WT", response_variable = "Metabolite", Factor = "Background", log_transform = TRUE)
DF_stats_trunc = DF_stats[,c(1,6,7,8,9,10)]
kable(DF_stats_trunc[1:3,])
```

including adjusted p values ("padj"), log2FoldChange, and standard error for each of the metabolites. From here, we can take this data frame and use it to create bar plots, volcano plots, or pie charts (see Data Visualization), or we can subset the metabolites based on their significance and/or their class meta data, and use ```KEGG_gather``` to get functional orthologies and gene info for our metabolites.

An alternative to the ```T_Test``` is the ```anova_function```, which can be used to measure the variance of all variable groups within a Factor at once, or see if independent variables have an effect on one another by modeling an interaction term (this only applies to multi factorial datasets).```anova_function``` has the same arguments as ```T_Test```, except "numerator" and "denominator" replaced by the names of your Factors, and interaction, which takes a value of TRUE or FALSE. Currently, it supports an interaction term containing two Factors. With this dataset, you could use an anova to observe if mouse background has an effect on how strep treatment effects the metabolome of the mice by using the following code:

```
DF_anova <- anova_function(data = c57_nos2KO_mouse_countDF, colData = c57_nos2KO_mouse_metadata, response_variable = "Metabolite", Var1 = "Background", Var2 = "Treatment", interaction = TRUE, log_transform = TRUE)
```

This should produce the follwing matrix:


```{r echo=FALSE,message=FALSE, warning=FALSE}
library(plotrix)
DF_anova <- anova_function(data = data, colData = c57_nos2KO_mouse_metadata, response_variable = "Metabolite", Var1 = "Background", Var2 = "Treatment", interaction = TRUE, log_transform = TRUE)
DF_anova_trunc = DF_anova[,c(1:7)]
kable(DF_anova_trunc[1:3,])
```

The output gives you columns with pvalues for ```Var1```, ```Var2```, and your interaction term. The adjusted p value is for the interaction term.

An alternative to doing an anova model with an interaction statement is to paste factor groups together using base R to make a new metadata column to be able to model the effect of treatment within mouse genetic backgrounds. For example, we can use base R to make a new "Grouped" Factor, with 4 levels; WTMock, WTStrep, Nos2Mock, and Nos2Strep.

```
c57_nos2KO_mouse_metadata$Grouped <- factor(paste0(c57_nos2KO_mouse_metadata$Background, c57_nos2KO_mouse_metadata$Treatment))
```

This should give us a meta data file that looks like this :

```{r echo=FALSE, message=FALSE, warning=FALSE}
c57_nos2KO_mouse_metadata$Grouped <-factor(paste0(c57_nos2KO_mouse_metadata$Background,
c57_nos2KO_mouse_metadata$Treatment))
kable(c57_nos2KO_mouse_metadata[1:4,])
```

We can then perform a T Test like we did above to model the effect of strep treatment on the wild type mouse metabolome, this time using the "Grouped" column as our factor, WTStrep as the numerator term, and WTMock as the denominator term:

```
DF_stats_grouped <- T_Test(data = c57_nos2KO_mouse_countDF, colData = c57_nos2KO_mouse_metadata, numerator = "WTStrep", denominator = "WTMock", response_variable = "Metabolite", Factor = "Grouped", log_transform = TRUE)
```

Giving us this data frame:

```{r echo=FALSE,message=FALSE, warning=FALSE}
library(plotrix)
DF_stats_grouped <- T_Test(data = data, colData = c57_nos2KO_mouse_metadata, numerator = "WTStrep", denominator = "WTMock", response_variable = "Metabolite", Factor = "Grouped", log_transform = TRUE)
DF_stats_grouped_trunc = DF_stats_grouped[,c(1,6,7,8,9,10)]
kable(DF_stats_grouped_trunc[1:3,])
```

### Gathering Functional Orthology and Gene Data

To gather functional orthology and gene data, Omu uses an S3 method called ```KEGG_gather```, which retrieves data from the KEGG API and cleans it up into a readable format as new columns in your data frame. KEGG_gather can recognize the class of your dataframe, which changes based on what identifier columns your data has acquired. This means that you can simply use the function ```KEGG_gather```, regardless of what data you want to collect. For advanced users, additional methods and classes can be added to ```KEGG_gather``` if you want something other than functional orthologies and genes. This can be done by altering the variables that are fed into the internal ```make_omelette``` function and creating a new ```plate_omelette``` method that appropriately cleans up the data.  

It is recommended that you subset your dataframe before using KEGG_gather, as compounds can have multiple functional orthologies associated with them. Lets subset the dataframe we created from using ```T_Test``` to Organic acids only using base R's ```subset``` function.

```
DF_stats_sub <- subset(DF_stats, Class=="Organic acids")
```

Now we should have a dataframe containing only compounds that are classified as Organic acids. We can now use KEGG_gather to get the functional orthologies for these compounds, and include a significance threshold to subset our data further:

```
DF_stats_sub_KO <- KEGG_gather(DF_stats_sub, sig_threshold = 0.05)
```

The data frame should now have functional orthologies and KO_numbers columns added. From here, we can assign hierarchy data for the orthologies with ```assign_hierarchy```

```
DF_stats_sub_KO <- assign_hierarchy(data = DF_stats_sub_KO, keep_unknowns = TRUE, identifier = "KO_number")
```

This should give us three new columns of metadata for the orthologies, we can now subset the orthologies to those associated with metabolism, using ```subset```.

```
DF_stats_sub_KO <- subset(DF_stats_sub_KO, KO_Class=="Metabololism")
```

Now that the data is reduced, lets use ```KEGG_gather``` again to get gene information.

```
DF_genes <- KEGG_gather(data = DF_stats_sub_KO)
```

The output of this function will be very large, on the order of tens of thousands of observations. This is because it pulls genes associated with the functional orthologies for all organisms in the KEGG data base. We can narrow the data frame down to data we are interested in by assigning either prokaryotic or eukaryotic organism hierarchy data to it and then subset by an organism of interest. For example, lets narrow our genes down to only those found within the genus Pseudomonas. To do this, we can start by assigning prokaryotic class hierarchy data:

```
DF_genes_Prokaryotes <- assign_hierarchy(data = DF_genes, keep_unknowns = FALSE, identifier = "Prokaryote")
```

This should add prokaryote hierarchy data while also eliminating any rows with eukaryotic organism genes. Now, we can use ```subset``` to select for genes within Pseudomonas:

```
DF_genes_pseudomonas <- subset(DF_genes_Prokaryotes, Genus=="Pseudomonas")
```

Now we have a much smaller table that can easily be explored! Performing these gene and hierarchical class assignments can be useful for those doing metabolomics to fish for a hypothesis, if they want to study organisms with a reductionist approach, for example, if they find a compound or compounds that changed between treatment groups, and then look for genes in their organism of interest involved in utlizing the compounds.

## Data Visualization

### Bar Plots
The ```plot_bar``` function can be used to make bar plots of metabolite counts by their class meta data (from ```assign_hierarchy```). To make a bar plot, first we can take the output of grouped samples we created from ```T_Test``` and use the function ```count_fold_changes``` to make a dataframe with the number of compounds that significantly increased or decreased per Class level.

```
DF_stats_counts <- count_fold_changes(data = DF_stats_grouped, "Class", column = "Class", sig_threshold = 0.05)
```
This should generate a dataframe with 4 columns that show Class, number of compounds within that class that increased significantly, decreased significantly, or total significant changes. Before moving on to plotting, lets remove any compounds that weren't assigned hierarchy data (these should be labeled under NA):

```
DF_stats_counts <- drop_na(DF_stats_counts)
```
This gives us the following table:

```{r echo=FALSE}
DF_stats_counts <- count_fold_changes(data = DF_stats_grouped, "Class", column = "Class", sig_threshold = 0.05)
DF_stats_counts <- drop_na(DF_stats_counts)
kable(DF_stats_counts)
```

We can now use this count data frame as an input for the ```plot_bar``` function:

```
Class_Bar_Plot <- plot_bar(data = DF_stats_counts, fill = c("dodgerblue2", "firebrick2"), color = c("black", "black"), size = c(1,1)) + labs(x = "Class") + theme(panel.grid = element_blank())
```

This should generate a plot that looks like this:

```{r echo=FALSE, fig.keep='all', results='hide'}
Class_Bar_Plot <- plot_bar(data = DF_stats_counts, fill = c("dodgerblue2", "firebrick2"), color = c("black", "black"), size = c(1,1)) + labs(x = "Class") + theme(panel.grid = element_blank())
plot(Class_Bar_Plot)
```

Fill is the color of the bars, and color is the outline. Colors are picked in alphanumeric order, so the first item in each character vector corresponds to the "Decrease" column and the second corresponds to the "Increase" column. The figure is a ggplot2 object, so it is compatible with any ggplot2 themes you wish to use to edit the appearance. We actually did this by adding ```labs(x = "Class") + theme(panel.grid = element_blank())``` at the end of our line of code to clean up the figures appearance by giving it a descriptive x axis label and removing the grid lines from the background.

### Pie Charts

It is also possible to make a pie_chart from our counts data frame instead of a bar plot. First, we can make a frequency data frame (percentage values) from our count data frame using the ```ra_table``` function:

```
DF_ra <- ra_table(data = DF_stats_counts, variable = "Class")
```

This should generate a data frame with percentages of compounds that increased significantly, decreased significantly, or changed significantly:

```{r echo=FALSE}
DF_ra <- ra_table(data = DF_stats_counts, variable = "Class")
kable(DF_ra)
```

We can take this frequency data frame and input it into the ```pie_chart``` function:

```
Pie_Chart <- pie_chart(data = DF_ra, variable = "Class", column = "Decrease", color = "black")
```

We should now have a pie chart showing the percent of compounds that decreased per class level:

```{r echo=FALSE, warning=FALSE}
Pie_Chart <- pie_chart(data = DF_ra, variable = "Class", column = "Decrease", color = "black")
plot(Pie_Chart)
```

### Volcano Plots

We can also just take the grouped output from ```T_Test``` and make a volcano plot, using ```plot_volcano```. It gives you the option to highlight data points in the plot by their hiearchy meta data (Class, Subclass_1, etc.) For example, we can make a Volcano plot that highlight all of the compounds that are either Organic acids or Carbohydrates. Note that when picking things like color, fill, or transparency (alpha), the values are ordered alphanumerically, and anything not listed in the "strpattern" argument is called "NA". If the strpattern argument is not used, all points below the chosen sigthreshold value will be colored red:

```
Volcano_Plot <- plot_volcano(data = DF_stats_grouped, size = 2, column = "Class", strpattern = c("Organic acids, Carbohydrates"), fill = c("firebrick2","white","dodgerblue2"), color = c("black", "black", "black"), alpha = c(1,1,1), shape = c(21,21,21)) + theme_bw() + theme(panel.grid = element_blank())
```

This will give us the following plot:

```{r echo=FALSE, warning=FALSE, results='hide', fig.keep='all'}
Volcano_Plot <- plot_volcano(data = DF_stats_grouped, size = 2, column = "Class", strpattern = c("Organic acids", "Carbohydrates"), fill = c("firebrick2","white","dodgerblue2"), color = c("black", "black", "black"), alpha = c(1,1,1), shape = c(21,21,21)) + theme_bw() + theme(panel.grid = element_blank())
plot(Volcano_Plot)
```

With the dashed line representing the significance threshold you chose.

### PCA Plots

Omu also supports multivariate statistical analysis and visualization in the form of principle component analysis. To do this one only needs to have their metabolomics count data and meta data in the proper format. We can make a PCA plot showing the relationship between Treatment groups:

```
PCA <- PCA_plot(data = germ_free_countDF, colData = germ_free_metadata, variable = "Treatment", color = "Treatment", response_variable = "Metabolite")+ theme_bw() + theme(panel.grid = element_blank())
```

This should make the following figure:

```{r echo=FALSE, warning=FALSE}
library(ggfortify)
load("Omu/Omu/data/c57_nos2KO_mouse_countDF.rda")
PCA <- PCA_plot(data = c57_nos2KO_mouse_countDF, colData = c57_nos2KO_mouse_metadata, variable = "Grouped", color = "Grouped", response_variable = "Metabolite") + theme_bw() + theme(panel.grid = element_blank())
plot(PCA)
```
